# BLE Pairing and Security Documentation

This document explains the Bluetooth Low Energy (BLE) pairing and security mechanisms used in the TLSR8266 mesh light system. It covers the pairing state machine, protocol flow, security features, and includes practical examples.

## Table of Contents

- [Overview](#overview)
- [Pairing State Machine](#pairing-state-machine)
- [Pairing Protocol Flow](#pairing-protocol-flow)
- [Security Features](#security-features)
- [Key Management](#key-management)
- [Mesh Network Support](#mesh-network-support)
- [Example: Complete Pairing Sequence](#example-complete-pairing-sequence)
- [Troubleshooting and Common Issues](#troubleshooting-and-common-issues)
- [Client-Side Implementation](#client-side-implementation)

## Overview

The BLE pairing mechanism secures communication between the client application and the TLSR8266 mesh light devices. Pairing establishes secure session keys and allows the client to provision mesh network parameters to devices.

The pairing system supports two security modes:
1. **Simple mode**: Uses basic XOR operations for credential verification
2. **Secure mode**: Uses AES encryption for packet security, key derivation, and credential verification

Key components of the pairing mechanism:
- **Session Key (SK)**: Temporary key used to encrypt communication during a session
- **Long-term Key (LTK)**: Persistent key stored in flash and used for mesh encryption
- **Mesh Name (NN)**: Name of the mesh network (null-terminated string, max 16 bytes)
- **Mesh Password (Pass)**: Password for mesh network authentication (16 bytes)

### GATT Characteristics

The pairing protocol operates through the following GATT characteristics:

| Name | UUID | Description |
|------|------|-------------|
| Pair | 00010203-0405-0607-0809-0a0b0c0d1914 | Used for all pairing operations (key exchange, provisioning) |
| Command | 00010203-0405-0607-0809-0a0b0c0d1912 | Used for encrypted mesh commands after pairing |
| Notify | 00010203-0405-0607-0809-0a0b0c0d1911 | Used for device status notifications |

The pairing characteristic (`0x1914`) handles all pairing protocol operations, while the command characteristic (`0x1912`) is used for post-pairing mesh control after a secure session has been established.

## Pairing State Machine

The pairing process is controlled by a state machine that tracks the progress of the pairing protocol. The state is represented by the `PairState` enum:

```rust
#[repr(u8)]
pub enum PairState {
    Idle = 0x00,                      // Initial/idle state
    Reserved = 0x01,                  // Reserved (unused state)
    AwaitingRandom = 0x02,            // Waiting for random challenge
    Reserved3 = 0x03,                 // Reserved (unused state)
    Reserved4 = 0x04,                 // Reserved (unused state)
    ReceivingMeshName = 0x05,         // Receiving mesh name
    ReceivingMeshPassword = 0x06,     // Receiving mesh password
    ReceivingMeshLtk = 0x07,          // Receiving long-term key
    Reserved8 = 0x08,                 // Reserved (unused state)
    RequestingLtk = 0x09,             // Requesting LTK
    ResetMesh = 0x0A,                 // Reset mesh configuration
    DeletePairing = 0x0B,             // Deleting pairing
    RandomConfirmation = 0x0C,        // Random value confirmation
    SessionKeyExchange = 0x0D,        // Session key exchange
    Init = 0x0E,                      // Initialization state
    Completed = 0x0F,                 // Pairing process completed
}
```

The state transitions occur as the client and server exchange messages using opcode-based commands in the `pair_write` function and responses generated by the `pair_proc` function.

### Key State Transitions

The following diagram shows the major state transitions in the pairing process:

```
    Idle
     |
     v
AwaitingRandom ---------> RandomConfirmation
     ^                          |
     |                          v
     |                  SessionKeyExchange
     |                          |
     v                          v
  Completed <--------- ReceivingMeshName
     |                          |
     |                          v
     |                 ReceivingMeshPassword
     |                          |
     |                          v
     |                  ReceivingMeshLtk
     |                          |
     v                          v
RequestingLtk                Completed
```

## Pairing Protocol Flow

The pairing protocol consists of five main phases:

### Pairing Opcodes Reference

The following opcodes are used for communication between client and server throughout the pairing protocol:

| Opcode | Hex Value | Description | Server State Transition |
|--------|-----------|-------------|-------------------------|
| `PAIR_OP_EXCHANGE_RANDOM` | 0x01 | Exchange random challenge | `Idle` → `AwaitingRandom` |
| `PAIR_OP_SET_MESH_NAME` | 0x04 | Set mesh network name | `SessionKeyExchange`/`Completed` → `ReceivingMeshName` |
| `PAIR_OP_SET_MESH_PASSWORD` | 0x05 | Set mesh network password | `ReceivingMeshName` → `ReceivingMeshPassword` |
| `PAIR_OP_SET_MESH_LTK` | 0x06 | Set long-term key | `ReceivingMeshPassword` → `ReceivingMeshLtk` → `Completed` |
| `PAIR_OP_GET_MESH_LTK` | 0x08 | Request long-term key | `Completed` → `RequestingLtk` → `Completed` |
| `PAIR_OP_RESET_MESH` | 0x0A | Reset mesh configuration | → `ResetMesh` |
| `PAIR_OP_VERIFY_CREDENTIALS` | 0x0C | Verify credentials | `AwaitingRandom` → `RandomConfirmation` → `SessionKeyExchange` |
| `PAIR_OP_DELETE_PAIRING` | 0x0E | Delete pairing information | Any → `Idle` |

Both the client and server must use these same opcodes for consistent communication.

### 1. Random Exchange

- Client sends `PAIR_OP_EXCHANGE_RANDOM` (0x01) with random challenge (`pair_randm`)
- Server transitions to `AwaitingRandom` state and responds with its own random challenge (`pair_rands`)
- Server advances to `RandomConfirmation` state awaiting credential verification

### 2. Authentication

- Client sends `PAIR_OP_VERIFY_CREDENTIALS` (0x0C) with proof derived from credentials
- Server verifies the proof by comparing it with the expected value
- If verification succeeds, server sets `PAIR_LOGIN_OK` flag and transitions to `SessionKeyExchange` state
- Server responds with session key material

### 3. Provisioning (after successful authentication)

- Client sends `PAIR_OP_SET_MESH_NAME` (0x04) with mesh network name
  - Server transitions to `ReceivingMeshName` state
- Client sends `PAIR_OP_SET_MESH_PASSWORD` (0x05) with mesh network password
  - Server transitions to `ReceivingMeshPassword` state
- Client sends `PAIR_OP_SET_MESH_LTK` (0x06) with long-term key
  - Server transitions to `ReceivingMeshLtk` state
  - Server saves pairing information to flash and transitions to `Completed` state

### 4. Key Management

- Client can request LTK with `PAIR_OP_GET_MESH_LTK` (0x08)
  - Server transitions to `RequestingLtk` state
- Client can reset mesh with `PAIR_OP_RESET_MESH` (0x0A)
  - Server transitions to `ResetMesh` state

### 5. Maintenance

- Client can delete pairing with `PAIR_OP_DELETE_PAIRING` (0x0E)
  - Server transitions to `Idle` state and clears pairing information

## Security Features

The pairing protocol incorporates several security features:

### Security Mode Negotiation

The protocol supports two security modes that must be correctly matched between client and server:

- **Server Configuration**: The server's security mode is determined by the `SECURITY_ENABLE` flag in firmware.
- **Client Configuration**: The client must be configured to use the same security mode as the server.

Security modes are not automatically negotiated - they must be pre-configured to match:

| Server Mode | Client Mode | Result |
|-------------|-------------|--------|
| Simple Mode (`SECURITY_ENABLE=false`) | Simple Mode | ✓ Successful pairing |
| Secure Mode (`SECURITY_ENABLE=true`) | Secure Mode | ✓ Successful pairing |
| Simple Mode | Secure Mode | ✗ Authentication fails |
| Secure Mode | Simple Mode | ✗ Authentication fails |

When security mode mismatch occurs, authentication will fail during the credential verification phase since the proof formats differ between modes.

### Session Key Derivation

In secure mode, the session key (SK) is derived using the following steps:

1. Initial SK generation using XORed random values:
   ```
   pair_sk = AES_encrypt(pair_randm, pair_rands)
   ```

2. Final SK derivation with credentials:
   ```
   work_buffer = pair_nn ^ pair_pass
   pair_sk[0:8] = pair_randm
   pair_sk[8:16] = pair_rands
   pair_sk = AES_encrypt(work_buffer, pair_sk)
   ```

### Credential Verification

Two methods of credential verification are supported:

1. **Simple mode**:
   ```
   verification_material = pair_nn ^ pair_pass
   if verification_material == client_proof
       // Verification succeeded
   ```

2. **Secure mode**:
   ```
   verification_material = pair_nn ^ pair_pass
   encrypted_proof = AES_encrypt(session_key, verification_material)
   if encrypted_proof[0:8] == client_proof[9:17]
       // Verification succeeded
   ```

### Packet Encryption

When `SECURITY_ENABLE` is true, packets are encrypted using AES-CCM:

1. For BLE packets:
   - Session key (pair_sk) is used for encryption
   - Initialization vectors include sequence numbers to prevent replay attacks

2. For Mesh packets:
   - Long-term key (pair_ltk) is used for encryption
   - Broadcast and direct mesh packets use different encryption formats

## Key Management

The pairing system manages several types of keys:

### Session Keys

- **Purpose**: Secure temporary communication during a BLE connection
- **Storage**: RAM only, not persisted
- **Derivation**: Generated during pairing using random challenges and credentials
- **Usage**: Encrypts BLE packets when `SECURITY_ENABLE` is true

### Long-term Keys (LTK)

- **Purpose**: Long-term encryption of mesh network communication
- **Storage**: Persisted in flash memory
- **Management**: Set during provisioning, can be requested later
- **Usage**: Encrypts mesh packets when `SECURITY_ENABLE` is true

### Credentials (Mesh Name and Password)

- **Purpose**: Authentication and mesh network identification
- **Storage**: Persisted in flash memory (password is encoded for storage)
- **Usage**: Used for credential verification and mesh access code generation

## Mesh Network Support

The pairing system includes special support for mesh networks:

### Mesh LTK

During provisioning, a special mesh LTK can be provided with the `MESH_FLAG_OFFSET` bit set in the packet. This triggers mesh-specific behavior:

```rust
if MESH_PAIR_ENABLE.get() && MIN_PACKET_LEN_WITH_MESH < data.head().l2cap_len && data.att_write().value[MESH_FLAG_OFFSET] != 0 {
    // This is a mesh LTK - decrypt and prepare for mesh mode
    aes_att_decryption(&pair_state.pair_sk.clone(), &pair_state.pair_work.clone(), &mut pair_state.pair_ltk_mesh);
    *PAIR_SETTING_FLAG.lock() = ePairState::PairSetMeshTxStart;
    return true;
}
```

### MAC Address Handling

The pairing system can enable or disable MAC address handling for mesh communication using the `GET_MAC_EN` flag.

### Mesh Access Codes

The `pair_update_key` function generates mesh access codes from the pairing credentials:

```rust
PAIR_AC.set(access_code(&pair_state.pair_nn, &pair_state.pair_pass));
```

## Example: Complete Pairing Sequence

Here's a complete example of a pairing sequence between a client application and a TLSR8266 device:

### Pre-conditions
- Device is in advertising state
- Client has connected to the device

### 1. Random Exchange

**Client sends:**
```
Opcode: PAIR_OP_EXCHANGE_RANDOM (0x01)
Data: [a0, a1, a2, a3, a4, a5, a6, a7]  // pair_randm (8 bytes random challenge)
```

**Server responds:**
```
Value[0]: PAIR_STATE_AWAITING_RANDOM (0x02)  // Current state
Value[1:9]: [b0, b1, b2, b3, b4, b5, b6, b7]  // pair_rands (8 bytes random challenge)
```

### 2. Authentication

**Client sends:**
```
Opcode: PAIR_OP_VERIFY_CREDENTIALS (0x0C)
Data[0:8]: [a0, a1, a2, a3, a4, a5, a6, a7]  // pair_randm (same as before)
Data[9:17]: [c0, c1, c2, c3, c4, c5, c6, c7]  // Proof of credentials (simple or encrypted)
```

**Server responds:**
```
Value[0]: PAIR_STATE_SESSION_KEY_EXCHANGE (0x0D)  // Current state
Value[1:9]: [b0', b1', b2', b3', b4', b5', b6', b7']  // Updated pair_rands
Value[9:17]: [d0, d1, d2, d3, d4, d5, d6, d7]  // Server's proof of credentials
```

### 3. Provisioning

**Client sends:**
```
Opcode: PAIR_OP_SET_MESH_NAME (0x04)
Data: "MyMeshNetwork\0"  // Mesh name (16 bytes, null-terminated)
```

**Server responds:**
```
Value[0]: PAIR_STATE_RECEIVING_MESH_NAME (0x05)  // Current state
```

**Client sends:**
```
Opcode: PAIR_OP_SET_MESH_PASSWORD (0x05)
Data: [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe, pf]  // Password (16 bytes)
```

**Server responds:**
```
Value[0]: PAIR_STATE_RECEIVING_MESH_PASSWORD (0x06)  // Current state
```

**Client sends:**
```
Opcode: PAIR_OP_SET_MESH_LTK (0x06)
Data: [k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, ka, kb, kc, kd, ke, kf]  // LTK (16 bytes)
Data[17]: 0x01  // Mesh LTK flag
```

**Server:**
- Saves pairing information to flash
- Calls `rf_link_light_event_callback(LGT_CMD_PAIR_OK)`

**Server responds:**
```
Value[0]: PAIR_STATE_COMPLETED (0x0F)  // Current state
```

### 4. Key Management (Optional)

**Client sends:**
```
Opcode: PAIR_OP_GET_MESH_LTK (0x08)
Data[0:8]: [a0, a1, a2, a3, a4, a5, a6, a7]  // Random challenge
Data[9:17]: [c0, c1, c2, c3, c4, c5, c6, c7]  // Proof of credentials
```

**Server responds:**
```
Value[0]: PAIR_STATE_REQUESTING_LTK (0x09)  // Current state
Value[1:17]: [k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, ka, kb, kc, kd, ke, kf]  // LTK (16 bytes)
```

### 5. Maintenance (Optional)

**Client sends:**
```
Opcode: PAIR_OP_DELETE_PAIRING (0x0E)
```

**Server:**
- Deletes pairing information
- Calls `rf_link_light_event_callback(LGT_CMD_DEL_PAIR)`

## Troubleshooting and Common Issues

### Authentication Failures

- **Issue**: Client fails credential verification
  - **Cause**: Incorrect mesh name or password
  - **Solution**: Verify credentials match those stored on the device
  - **Server State**: Resets to `Idle` state (0x00)

- **Issue**: Server rejects client proof
  - **Cause**: Mismatch between client's security mode and server's `SECURITY_ENABLE` flag
  - **Solution**: Ensure client and server use the same security mode
  - **Server State**: Remains in `RandomConfirmation` state (0x0C) without setting `PAIR_LOGIN_OK`

### State Machine Errors

- **Issue**: Server resets to `Init` state during provisioning
  - **Cause**: Invalid state transition or security violation
  - **Solution**: Follow the correct sequence of pairing operations
  - **Client Handling**: Detect `Init` state (0x0E) and restart the pairing process

- **Issue**: Server stuck in a specific state
  - **Cause**: Missing or out-of-order pairing operations
  - **Solution**: Reset the connection and restart pairing from the beginning
  - **Client Handling**: Implement timeouts for each state and reset if no progress

### Encryption Issues

- **Issue**: Decryption failures after successful pairing
  - **Cause**: Session key or initialization vectors not properly synchronized
  - **Solution**: Re-establish the connection to regenerate session keys
  - **Detection**: Command responses contain invalid data or fail CRC checks

- **Issue**: Mesh communication failures
  - **Cause**: LTK mismatch between devices
  - **Solution**: Ensure all devices in the mesh have the same LTK
  - **Detection**: Mesh devices do not respond to encrypted broadcast messages

## Client-Side Implementation

This section details the algorithms and protocols used by the client to implement the pairing process for TLSR8266 mesh light devices. These algorithms are critical for successfully authenticating, establishing secure sessions, and provisioning devices into a mesh network.

### Server State to Client Action Mapping

The client implementation must respond appropriately to each server state. The following table shows the mapping between server states and expected client actions:

| Server State | State Code | Client Action |
|--------------|------------|--------------|
| `Idle` | 0x00 | Send random challenge via `PAIR_OP_EXCHANGE_RANDOM` |
| `AwaitingRandom` | 0x02 | Extract server random and send credentials via `PAIR_OP_VERIFY_CREDENTIALS` |
| `SessionKeyExchange` | 0x0D | Derive session key and begin provisioning with `PAIR_OP_SET_MESH_NAME` |
| `ReceivingMeshName` | 0x05 | Send mesh password via `PAIR_OP_SET_MESH_PASSWORD` |
| `ReceivingMeshPassword` | 0x06 | Send LTK via `PAIR_OP_SET_MESH_LTK` |
| `Completed` | 0x0F | Begin normal mesh operations or request LTK via `PAIR_OP_GET_MESH_LTK` |
| `Init` | 0x0E | Error state - reset connection and restart pairing |

Each server state requires specific client handling to advance the pairing process. The client monitors the first byte of each response from the server (via read operations on the pairing characteristic) to determine the current server state.

### Key Algorithms

#### Mesh Credential Encoding Algorithm

**Purpose**: Generate verification material for authentication by combining mesh name and password

**Algorithm**:
1. Truncate both mesh name and password to 16 bytes (if longer)
2. Pad both values with null bytes to exactly 16 bytes
3. XOR each corresponding byte of name and password
4. Result is 16-byte credential verification material used for authentication

#### Byte Order Handling for AES Encryption 

**Purpose**: Ensure compatibility with device firmware's cryptographic implementation

**Algorithm**:
1. Reverse byte order of encryption key (input)
2. Reverse byte order of plaintext data (input)
3. Apply standard AES-ECB encryption
4. Return resulting ciphertext without reversing (compatible with next operations)

#### Session Key Derivation

**Purpose**: Establish a secure session key with mutual verification of credentials

**Algorithm**:
1. Extract server's session key material and random challenge from response
2. Pad server's random challenge to 16 bytes
3. Encrypt mesh credentials (XORed name/password) with server's challenge
4. Create verification material by:
   - Taking server's random challenge (first 8 bytes)
   - Taking bytes 8-15 from the encrypted credentials
   - Applying section-specific byte reversals
5. Validate server's session key against calculated verification material
6. Generate final session key:
   - Combine client random (first 8 bytes) and server random (last 8 bytes)
   - Encrypt this with mesh credentials
   - Apply final byte order reversal
   - Result is the session key for encrypted communications

### Pairing Process Phases

#### 1. Authentication and Session Establishment

**Purpose**: Mutually verify credentials and establish secure communication

**Protocol Flow**:
1. Client generates 8-byte random challenge
2. Client encodes mesh credentials (XOR of name and password)
3. Client pads random challenge to 16 bytes with zeros
4. Client encrypts credentials with padded random challenge
5. Client constructs authentication packet:
   - Opcode: `PAIR_OP_VERIFY_CREDENTIALS`
   - First 8 bytes: Client's random challenge
   - Next 8 bytes: Part of encrypted credentials (with byte reversals)
6. Client sends packet to server via GATT write
7. Server validates credentials and responds
8. Client processes response to derive and validate session key
9. If validation succeeds, secure session is established

#### 2. Device Configuration for Mesh

**Purpose**: Configure the device with its mesh network address

**Protocol Flow**:
1. Client encrypts a command to set mesh address (opcode 0xE0)
2. Command is encrypted using the established session key
3. Encryption process uses:
   - Device MAC address as part of the nonce
   - Unique header ID to prevent replay attacks
   - AES-CCM style encryption with MAC tag generation
4. Command includes the assigned mesh address (1-63, must be unique in network)
5. Command is sent directly to the device (not through mesh)
6. Device processes command and updates its configuration

#### 3. Provisioning Mesh Parameters

**Purpose**: Configure device with mesh network parameters for secure mesh operation

**Protocol Flow**:
1. **Mesh Name Provisioning**:
   - Pad mesh name to 16 bytes
   - Encrypt with session key
   - Apply byte-order reversal
   - Add appropriate opcode (`PAIR_OP_SET_MESH_NAME`)
   - Send to device
   - Wait for state transition acknowledgement

2. **Mesh Password Provisioning**:
   - Pad password to 16 bytes
   - Encrypt with session key
   - Apply byte-order reversal
   - Add appropriate opcode (`PAIR_OP_SET_MESH_PASSWORD`)
   - Send to device
   - Wait for state transition acknowledgement

3. **Mesh LTK Provisioning**:
   - Use default LTK or validate custom LTK (16 bytes / 32 hex chars)
   - Encrypt LTK with session key
   - Apply byte-order reversal
   - Add appropriate opcode (`PAIR_OP_SET_MESH_LTK`)
   - Add mesh flag byte (0x01) to indicate this is for mesh network encryption
   - Send to device
   - Verify successful provisioning by checking device state

#### 4. Command Encryption for Mesh Communication

**Purpose**: Secure mesh commands after successful pairing

**Algorithm**:
1. **Nonce Generation**:
   - Use device's MAC address (byte-reversed)
   - Incorporate protocol version byte
   - Add unique 24-bit header ID (incremented for each command)
   - Result is 8-byte nonce for encryption

2. **Command Encryption Process** (AES-CCM style):
   - **MAC Tag Generation**:
     - Initialize block with nonce and message length
     - Encrypt initial block with session key
     - XOR with command data
     - Re-encrypt after each block
     - Use first 2 bytes as MAC tag
   
   - **Payload Encryption**:
     - Initialize counter block with nonce
     - Generate keystream by encrypting counter blocks
     - XOR command payload with keystream
     - Increment counter for each 16-byte block
   
   - **Command Assembly**:
     - Insert MAC tag into command
     - Include encrypted payload
     - Add required headers and metadata
   
3. **Command Transmission**:
   - Send encrypted command via appropriate GATT characteristic
   - Wait for acknowledgement if required

### Security Considerations

#### LTK Management

The client supports two modes of LTK provisioning:

1. **Default LTK**: Less secure as it's the same across implementations
2. **Custom LTK**: Recommended - provides unique 16-byte encryption key per mesh network

When using custom LTKs, the client validates:
- LTK length (must be exactly 32 hex characters / 16 bytes)
- LTK format (valid hexadecimal representation)
- Falls back to default LTK if validation fails (with user confirmation)

#### Mesh vs Standard LTK

The client handles two types of LTKs by adding a flag byte to the provisioning packet:
- Standard LTK: No additional flag byte
- Mesh LTK: Additional 0x01 byte appended to indicate mesh-specific encryption

This flag triggers special handling in the device firmware for mesh packet encryption.

#### Critical Byte Order Considerations

Byte order handling is essential throughout the pairing process:

1. **Encryption Operations**: Keys and data are byte-reversed before encryption
2. **Credential Verification**: Section-specific byte reversals for credential proofs
3. **MAC Address**: Stored in reverse order for nonce generation
4. **Session Key Derivation**: Specific byte order operations required during key computation
5. **LTK Handling**: LTK requires byte reversal before transmission

These byte order manipulations are not optional - they are required for compatibility with the TLSR8266 firmware implementation.